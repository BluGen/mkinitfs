#!/bin/sh

# this is the init script version
VERSION=@VERSION@
SINGLEMODE=no
sysroot=/sysroot

/bin/busybox mkdir -p /usr/bin /usr/sbin /proc /sys /dev $sysroot \
	/media/cdrom /media/floppy /media/usb /tmp
/bin/busybox --install -s

# basic environment
export PATH=/usr/bin:/bin:/usr/sbin:/sbin

# needed devs
[ -c /dev/null ] || mknod -m 666 /dev/null c 1 3

# basic mounts
mount -t proc -o noexec,nosuid,nodev proc /proc
mount -t sysfs -o noexec,nosuid,nodev sysfs /sys

# some helpers
ebegin() {
	echo -n " * $*: "
}
eend() {
	local msg
	if [ "$1" = 0 ] || [ $# -lt 1 ] ; then
		echo "ok."
	else
		shift
		echo "failed. $*"
		echo "initramfs emergency recovery shell launched. Type 'exit' to continue boot"
		/bin/busybox sh
	fi
}

scan_drivers() {
	if [ "$KOPT_autodetect" != no ] ; then
		find /sys -name modalias | xargs sort -u | xargs modprobe -a 2> /dev/null
	fi
}

find_ovl() {
	local mnt="$1"
	local ovl
	local lines

	# look for apkovl's on mounted media
	ovl=$( ls -1 "$mnt"/*.apkovl.tar.gz* 2>/dev/null ) || return 1
	lines=$(echo "$ovl" | wc -l)

	if [ $lines -gt 1 ] ; then
		echo "ERROR: More than one apkovl file was found on $(basename $mnt). None will be read." >&2
		return 1
	fi
	echo "$ovl"
}

retry_mount() {
	# usb might need some time to settle so we retry a few times
	for i in $(seq 0 9); do
		mount $@ 2>&1 && return 0
		sleep 1
	done
	return 1
}

unpack_apk() {
	local i
	for i in $ALPINE_MNT/*/*/$1-[0-9]*.apk $ALPINE_MNT/*/$1-[0-9]*.apk; do
		[ -f "$i" ] && tar --numeric-owner -C / -zxf $i && return 0
	done
	return 1
}

unpack_apkovl() {
	local ovl="$1"
	local dest="$2"
	local suffix=${ovl##*.}
	local i
	ovlfiles=/tmp/ovlfiles
	if [ "$suffix" = "gz" ]; then
		tar -C "$dest" -zxvf "$ovl" > $ovlfiles
		return $?
	fi

	unpack_apk uclibc
	unpack_apk libcrypto
	unpack_apk openssl

	if ! openssl list-cipher-commands | grep "^$suffix$" > /dev/null; then
		errstr="Cipher $suffix is not supported"
		return 1
	fi
	local count=0
	# beep
	echo -e "\007"
	while [ $count -lt 3 ]; do
		openssl enc -d -$suffix -in "$ovl" | tar --numeric-owner \
			-C "$dest" -zxv >$ovlfiles 2>/dev/null && return 0
		count=$(( $count + 1 ))
	done
	ovlfiles=
	return 1
}

# find mount dir for given device in an fstab
find_mnt() {
	local dev="$1"
	local fsfile="$2"
	awk "\$1 == \"$dev\" {print \$2}\"" "$fsfile" 2>/dev/null
}

# Wait for usb to settle
wait_usb() {
	if [ -n "$USB_DONE" ] || ! dmesg | grep '^usb-storage: waiting' >/dev/null; then
		return 0
	fi
	ebegin "Waiting for USB device to settle"
	while ! dmesg | grep 'usb-storage: device scan complete' >/dev/null; do
		sleep 1
	done
	USB_DONE=yes
	eend 0
}

#  add a boot service to $sysroot
rc_add() {
	mkdir -p $sysroot/etc/runlevels/$2
	ln -sf /etc/init.d/$1 $sysroot/etc/runlevels/$2/$1
}

# we have issues with some slow usb 1 hosts so we add 1 second delay
# with possibility to increase delay at boot prompt with usbdelay=<sec>
find_ovl_dev() {
	local n i
	# look for apkovl
	for n in $(seq 0 ${KOPT_usbdelay:-1}); do
		# wait for usb to settle if needed
		wait_usb
		for i in usb floppy cdrom; do
			mount /media/$i 2>/dev/null || continue
			ovl=$(find_ovl /media/$i)
			[ -f "$ovl" ] && return
			umount /media/$i 2>/dev/null
		done
		sleep 1
	done
}

setup_inittab_console(){
	while [ $# -gt 0 ]; do
		local tty=${1%,*}
		local speed=${1#*,}
		local line=
		local term=
		case "$tty" in
			ttyS*)
				[ "$speed" = "$1" ] && speed=9600
				term=vt100
				line=-L
				;;
			*)
				[ "$speed" = "$1" ] && speed=38400
				;;
		esac
		shift

		# do nothing if inittab already have the tty set up
		grep -q "^$tty:" $sysroot/etc/inittab && continue
		echo "# enable login on alternative console" >> $sysroot/etc/inittab
		echo "$tty::respawn:/sbin/getty $line $speed $tty $term" \
			>> $sysroot/etc/inittab
	done
}

# gotta start from somewhere :)
echo "Alpine Init $VERSION"

# read the kernel options. We use eval set so we can handle things like
# acpi_osi="!Windows 2006"
eval set -- `cat /proc/cmdline`

while [ $# -gt 0 ]; do
	case "$1" in
		s|single|1)
			SINGLEMODE=yes ;;
		console=*)
			CONSOLE="$CONSOLE ${1#console=}";;
		*=*)    eval "KOPT_${1%%=*}='${1#*=}'" ;;
		no*)    eval "KOPT_$(echo ${1#no} | sed 's: :_:g')=no" ;;
		*)      eval "KOPT_$(echo $1 | sed 's: :_:g')=yes" ;;
	esac
	shift
done

# start bootcharting if wanted
if [ "$KOPT_chart" = yes ]; then
	ebegin "Starting bootchart logging"
	/sbin/bootchartd start-initfs "$sysroot"
	eend 0
fi

# dma can be problematic
if [ "$KOPT_dma" = no ]; then
	modprobe libata dma=0
fi

ALPINE_DEV=${KOPT_alpine_dev%%:*}
ALPINE_DEV_FS=${KOPT_alpine_dev##*:}
if [ "$ALPINE_DEV_FS" = "$ALPINE_DEV" ]; then
	unset ALPINE_DEV_FS
fi

# look for standard mountpoint locations
ALPINE_MNT=$(find_mnt /dev/$ALPINE_DEV /etc/fstab)
[ -z "$ALPINE_MNT" ] && ALPINE_MNT=/media/$ALPINE_DEV

# hide kernel messages
[ "$KOPT_quiet" = yes ] && dmesg -n 1

# setup /dev
ebegin "Starting mdev"
mount -t tmpfs -o exec,nosuid,mode=0755,size=1M mdev /dev
echo "/sbin/mdev" > /proc/sys/kernel/hotplug
mdev -s
RC=$?
[ -d /dev/pts ] || mkdir -m 755 /dev/pts
[ -c /dev/ptmx ] || mknod -m 666 /dev/ptmx c 5 2
mount -t devpts -o gid=5,mode=0620,noexec,nosuid devpts /dev/pts
[ -d /dev/shm ] || mkdir /dev/shm
mount -t tmpfs -o nodev,nosuid,noexec shm /dev/shm
eend $RC

# load available drivers to get access to modloop media
ebegin "Loading boot drivers"

modprobe -a $(echo "$KOPT_modules" | tr ',' ' ' ) loop cramfs 2> /dev/null
if [ -f /etc/modules ] ; then
	sed 's/\#.*//g' < /etc/modules |
	while read module args; do
		modprobe -q $module $args
	done
fi
scan_drivers
scan_drivers
eend 0

# check if root=... was set
if [ -n "$KOPT_root" ]; then
	if [ "$SINGLEMODE" = "yes" ]; then
		echo "Entering single mode. Type 'exit' to continue booting."
		sh
	fi
	# let usb settle in case we boot from usb disks
	[ -n "$KOPT_usbdelay" ] && sleep "$KOPT_usbdelay"
	wait_usb
	case "$KOPT_root" in
		/dev/md*) 
			mknod $KOPT_root b 9 ${KOPT_root#/dev/md}
			raidautorun "$KOPT_root"
			;;
	esac
	ebegin "Mounting root"
	retry_mount $KOPT_root $sysroot 2>/dev/null
	eend $?
	cat /proc/mounts | while read DEV DIR TYPE OPTS ; do
		if [ "$DIR" != "/" -a "$DIR" != "$sysroot" -a -d "$DIR" ]; then
			mkdir -p $sysroot/$DIR
			mount -o move $DIR $sysroot/$DIR
		fi
	done
	sync
	exec /bin/busybox switch_root $sysroot $chart_init /sbin/init $KOPT_init_args
	echo "initramfs emergency recovery shell launched"
	exec /bin/busybox sh
fi

# we only want to wait for usb if really needed at this point
if [ -z "${ALPINE_DEV##*usb*}" ]; then
	wait_usb
fi

# locate boot media and mount it
ebegin "Mounting boot media"
mkdir -p $ALPINE_MNT
if [ -n "$ALPINE_DEV_FS" ]; then
	mount_opts="-t $ALPINE_DEV_FS"
fi

retry_mount $mount_opts /dev/$ALPINE_DEV $ALPINE_MNT >/dev/null 2>&1
eend $?

# early console?
if [ "$SINGLEMODE" = "yes" ]; then
	echo "Entering single mode. Type 'exit' to continue booting."
	sh
fi

# mount tmpfs sysroot
root_opts=
if [ -n "$KOPT_root_size" ]; then
	root_opts="-o size=$KOPT_root_size"
fi
mount -t tmpfs $root_opts tmpfs $sysroot

find_ovl_dev
if ! [ -f "$ovl" ]; then
	ovl=$(find_ovl $ALPINE_MNT)
fi

if [ -f "$ovl" ]; then
	ebegin "Loading user settings from $ovl"
	# create apk db and needed /dev/null and /tmp first
	apk add --root $sysroot --initdb --quiet

	unpack_apkovl "$ovl" $sysroot
	eend $? $errstr || ovlfiles=
	# hack, incase /root/.ssh was included in apkovl
	[ -d "$sysroot/root" ] && chmod 700 "$sysroot/root"
	umount /media/$i 2>/dev/null &
	pkgs=$(sed 's/\#.*//' $sysroot/etc/lbu/packages.list 2>/dev/null)
	rm -f "$sysroot"/etc/lbu/packages.list
	pkgs="$pkgs $(cat $sysroot/var/lib/apk/world 2>/dev/null)"
else
	# add some boot services by default
	rc_add devfs sysinit
	rc_add dmesg sysinit
	rc_add mdev sysinit

	rc_add hwclock boot
	rc_add modules boot
	rc_add sysctl boot
	rc_add hostname boot
	rc_add bootmisc boot
	rc_add syslog boot
	
	rc_add mount-ro shutdown
	rc_add killprocs shutdown
	rc_add savecache shutdown
fi

# let user override tmpfs size in fstab in apkovl
if [ -f $sysroot/etc/fstab ]; then
	mountopts=$(awk '$2 == "/" && $3 == "tmpfs" { print $4 }' $sysroot/etc/fstab)
	if [ -n "$mountopts" ]; then
		mount -o remount,$mountopts $sysroot
	fi
fi

# in case we upgrade we might need those:
rc_add hwdrivers sysinit
rc_add modloop sysinit


# hack so we get openrc
pkgs="$pkgs alpine-base"

# move the ALPINE_MNT if ALPINE_DEV is specified in users fstab
# this is so a generated /etc/apk/repositories will use correct mount dir
new_mnt=$(find_mnt /dev/$ALPINE_DEV $sysroot/etc/fstab)
if [ -n "$new_mnt" ] && [ "$new_mnt" != "$ALPINE_MNT" ]; then
	mkdir -p $new_mnt
	mount -o move $ALPINE_MNT $new_mnt
	ALPINE_MNT="$new_mnt"
fi

# copy keys so apk finds them. apk looks for stuff relative --root
mkdir -p $sysroot/etc/apk/keys/
cp -a /etc/apk/keys $sysroot/etc/apk

# generate apk repositories file and --repository opt 
echo "$(find $ALPINE_MNT -name .boot_repository -type f -maxdepth 3 \
	| sed 's:/.boot_repository$::')" > /tmp/repositories

if [ ! -f $sysroot/etc/apk/repositories ]; then
	mv /tmp/repositories $sysroot/etc/apk/
else
	for i in $(cat /tmp/repositories); do
		repo_opt="$repo_opt --repository $i"
	done
fi

# install new root
ebegin "Installing packages to root filesystem"
if [ "$KOPT_chart" = yes ]; then
	pkgs="$pkgs acct"
fi
apkflags="--initdb --quiet --progress --force --no-network"
if [ "$KOPT_keep_apk_new" != yes ]; then
	apkflags="$apkflags --clean-protected"
	[ -n "$ovlfiles" ] && apkflags="$apkflags --overlay-from-stdin"
fi

if [ -n "$ovlfiles" ]; then
	apk add --root $sysroot $repo_opt $apkflags $pkgs <$ovlfiles>/dev/null 
else
	apk add --root $sysroot $repo_opt $apkflags $pkgs >/dev/null
fi
eend $?

# fix inittab if alternative console
setup_inittab_console $CONSOLE

# copy alpine release info
cp $ALPINE_MNT/.alpine-release $sysroot/
ln -sf /.alpine-release $sysroot/etc/alpine-release

# setup bootchart for switch_root
chart_init=""
if [ "$KOPT_chart" = yes ]; then
	/sbin/bootchartd stop-initfs "$sysroot"
	chart_init="/sbin/bootchartd start-rootfs"
fi

if [ ! -x $sysroot/sbin/init ]; then
	echo "/sbin/init not found in new root. Launching emergency recovery shell"
	echo "Type exit to continue boot."
	/bin/busybox sh
fi

# switch over to new root
cat /proc/mounts | while read DEV DIR TYPE OPTS ; do
	if [ "$DIR" != "/" -a "$DIR" != "$sysroot" -a -d "$DIR" ]; then
		mkdir -p $sysroot/$DIR
		mount -o move $DIR $sysroot/$DIR
	fi
done
sync

echo ""
exec /bin/busybox switch_root $sysroot $chart_init /sbin/init $KOPT_init_args

echo "initramfs emergency recovery shell launched"
exec /bin/busybox sh
reboot
